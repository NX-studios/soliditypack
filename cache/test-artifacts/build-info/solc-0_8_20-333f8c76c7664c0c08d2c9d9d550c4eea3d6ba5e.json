{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-333f8c76c7664c0c08d2c9d9d550c4eea3d6ba5e",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/test/NestedStructuresTest.t.sol": "project/contracts/test/NestedStructuresTest.t.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/examples/NestedStructuresExample.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../SolidityPackEncoder.sol\";\nimport \"../SolidityPackDecoder.sol\";\nimport \"../SolidityPackTypes.sol\";\n\n/**\n * @title NestedStructuresExample\n * @notice Demonstrates encoding and decoding nested maps and arrays\n */\ncontract NestedStructuresExample {\n    using SolidityPackEncoder for *;\n    using SolidityPackDecoder for *;\n\n    // Example 1: Map with nested map\n    // Structure: {outer: 42, nested: {inner: 100, name: \"test\"}}\n    function encodeNestedMap() public pure returns (bytes memory) {\n        SolidityPackTypes.Encoder memory enc = SolidityPackEncoder.newEncoder();\n\n        SolidityPackEncoder.startMap(enc, 2);              // Outer map: 2 entries\n\n        SolidityPackEncoder.encodeString(enc, \"outer\");    // Entry 1: key\n        SolidityPackEncoder.encodeUint(enc, 42);           // Entry 1: value\n\n        SolidityPackEncoder.encodeString(enc, \"nested\");   // Entry 2: key\n        SolidityPackEncoder.startMap(enc, 2);              // Entry 2: value is a MAP!\n            SolidityPackEncoder.encodeString(enc, \"inner\"); // Nested key 1\n            SolidityPackEncoder.encodeUint(enc, 100);       // Nested value 1\n            SolidityPackEncoder.encodeString(enc, \"name\");  // Nested key 2\n            SolidityPackEncoder.encodeString(enc, \"test\");  // Nested value 2\n        // No \"end map\" needed - decoder counts!\n\n        return SolidityPackEncoder.getEncoded(enc);\n    }\n\n    // Example 2: Map with array value\n    // Structure: {name: \"Alice\", scores: [10, 20, 30]}\n    function encodeMapWithArray() public pure returns (bytes memory) {\n        SolidityPackTypes.Encoder memory enc = SolidityPackEncoder.newEncoder();\n\n        SolidityPackEncoder.startMap(enc, 2);\n\n        SolidityPackEncoder.encodeString(enc, \"name\");\n        SolidityPackEncoder.encodeString(enc, \"Alice\");\n\n        SolidityPackEncoder.encodeString(enc, \"scores\");\n        SolidityPackEncoder.startArray(enc, 3);            // Array as value!\n            SolidityPackEncoder.encodeUint(enc, 10);\n            SolidityPackEncoder.encodeUint(enc, 20);\n            SolidityPackEncoder.encodeUint(enc, 30);\n\n        return SolidityPackEncoder.getEncoded(enc);\n    }\n\n    // Example 3: Complex nesting\n    // Structure: {id: 1, data: {tags: [\"a\", \"b\"], active: true}, count: 5}\n    function encodeComplexNesting() public pure returns (bytes memory) {\n        SolidityPackTypes.Encoder memory enc = SolidityPackEncoder.newEncoder();\n\n        SolidityPackEncoder.startMap(enc, 3);                  // Level 1: Map with 3 entries\n\n        SolidityPackEncoder.encodeString(enc, \"id\");\n        SolidityPackEncoder.encodeUint(enc, 1);\n\n        SolidityPackEncoder.encodeString(enc, \"data\");\n        SolidityPackEncoder.startMap(enc, 2);                  // Level 2: Nested map\n            SolidityPackEncoder.encodeString(enc, \"tags\");\n            SolidityPackEncoder.startArray(enc, 2);            // Level 3: Array in nested map\n                SolidityPackEncoder.encodeString(enc, \"a\");\n                SolidityPackEncoder.encodeString(enc, \"b\");\n            SolidityPackEncoder.encodeString(enc, \"active\");\n            SolidityPackEncoder.encodeBool(enc, true);\n\n        SolidityPackEncoder.encodeString(enc, \"count\");\n        SolidityPackEncoder.encodeUint(enc, 5);\n\n        return SolidityPackEncoder.getEncoded(enc);\n    }\n\n    // Decode Example 1: Step by step\n    function decodeNestedMapStepByStep() public pure returns (\n        uint256 outerValue,\n        uint256 nestedInner,\n        string memory nestedName\n    ) {\n        // Get encoded data\n        bytes memory data = encodeNestedMap();\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        // Step 1: Decode outer map\n        uint256 outerLen = SolidityPackDecoder.decodeMapLength(dec);\n        require(outerLen == 2, \"Expected 2 entries\");\n\n        // Step 2: Decode first entry\n        string memory key1 = SolidityPackDecoder.decodeString(dec);\n        require(keccak256(bytes(key1)) == keccak256(\"outer\"), \"Expected 'outer'\");\n        outerValue = SolidityPackDecoder.decodeUint(dec);\n\n        // Step 3: Decode second entry key\n        string memory key2 = SolidityPackDecoder.decodeString(dec);\n        require(keccak256(bytes(key2)) == keccak256(\"nested\"), \"Expected 'nested'\");\n\n        // Step 4: Check that value is a map\n        SolidityPackDecoder.TypeCategory cat = SolidityPackDecoder.peekCategory(dec);\n        require(cat == SolidityPackDecoder.TypeCategory.MAP, \"Expected nested map\");\n\n        // Step 5: Decode nested map\n        uint256 nestedLen = SolidityPackDecoder.decodeMapLength(dec);\n        require(nestedLen == 2, \"Expected 2 nested entries\");\n\n        // Nested entry 1\n        SolidityPackDecoder.decodeString(dec); // key \"inner\"\n        nestedInner = SolidityPackDecoder.decodeUint(dec);\n\n        // Nested entry 2\n        SolidityPackDecoder.decodeString(dec); // key \"name\"\n        nestedName = SolidityPackDecoder.decodeString(dec);\n\n        return (outerValue, nestedInner, nestedName);\n    }\n\n    // Decode Example 2: Using type inspection\n    function decodeMapWithArrayUsingInspection() public pure returns (\n        string memory name,\n        uint256 firstScore,\n        uint256 scoresCount\n    ) {\n        bytes memory data = encodeMapWithArray();\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        uint256 mapLen = SolidityPackDecoder.decodeMapLength(dec);\n\n        for (uint256 i = 0; i < mapLen; i++) {\n            string memory key = SolidityPackDecoder.decodeString(dec);\n\n            if (keccak256(bytes(key)) == keccak256(\"name\")) {\n                // We know this is a string\n                name = SolidityPackDecoder.decodeString(dec);\n            } else if (keccak256(bytes(key)) == keccak256(\"scores\")) {\n                // Check if it's an array\n                require(\n                    SolidityPackDecoder.isCategory(dec, SolidityPackDecoder.TypeCategory.ARRAY),\n                    \"Expected array\"\n                );\n\n                scoresCount = SolidityPackDecoder.decodeArrayLength(dec);\n                firstScore = SolidityPackDecoder.decodeUint(dec);\n\n                // Skip the rest of the array\n                for (uint256 j = 1; j < scoresCount; j++) {\n                    SolidityPackDecoder.skip(dec);\n                }\n            } else {\n                // Unknown field, skip it\n                SolidityPackDecoder.skip(dec);\n            }\n        }\n\n        return (name, firstScore, scoresCount);\n    }\n\n    // Decode Example 3: Generic decoding with recursion-like pattern\n    function decodeComplexAndExtractTags() public pure returns (\n        string memory firstTag,\n        string memory secondTag,\n        bool foundTags\n    ) {\n        bytes memory data = encodeComplexNesting();\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        uint256 mapLen = SolidityPackDecoder.decodeMapLength(dec);\n\n        for (uint256 i = 0; i < mapLen; i++) {\n            string memory key = SolidityPackDecoder.decodeString(dec);\n\n            if (keccak256(bytes(key)) == keccak256(\"data\")) {\n                // This is the nested map we want\n                uint256 dataMapLen = SolidityPackDecoder.decodeMapLength(dec);\n\n                for (uint256 j = 0; j < dataMapLen; j++) {\n                    string memory nestedKey = SolidityPackDecoder.decodeString(dec);\n\n                    if (keccak256(bytes(nestedKey)) == keccak256(\"tags\")) {\n                        // Found the tags array!\n                        uint256 tagsLen = SolidityPackDecoder.decodeArrayLength(dec);\n                        if (tagsLen >= 2) {\n                            firstTag = SolidityPackDecoder.decodeString(dec);\n                            secondTag = SolidityPackDecoder.decodeString(dec);\n                            foundTags = true;\n\n                            // Skip remaining tags\n                            for (uint256 k = 2; k < tagsLen; k++) {\n                                SolidityPackDecoder.skip(dec);\n                            }\n                        }\n                    } else {\n                        // Skip other nested fields\n                        SolidityPackDecoder.skip(dec);\n                    }\n                }\n            } else {\n                // Skip other top-level fields\n                SolidityPackDecoder.skip(dec);\n            }\n        }\n\n        return (firstTag, secondTag, foundTags);\n    }\n\n    // Example: What if you start a map but then need to skip unknown nested structures?\n    function decodeUnknownStructureWithSkip() public pure returns (\n        uint256 id,\n        uint256 count\n    ) {\n        bytes memory data = encodeComplexNesting();\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        uint256 mapLen = SolidityPackDecoder.decodeMapLength(dec);\n\n        for (uint256 i = 0; i < mapLen; i++) {\n            string memory key = SolidityPackDecoder.decodeString(dec);\n\n            if (keccak256(bytes(key)) == keccak256(\"id\")) {\n                id = SolidityPackDecoder.decodeUint(dec);\n            } else if (keccak256(bytes(key)) == keccak256(\"count\")) {\n                count = SolidityPackDecoder.decodeUint(dec);\n            } else {\n                // Skip the entire \"data\" nested map without caring about its structure!\n                // The skip() function handles nested structures automatically\n                SolidityPackDecoder.skip(dec);\n            }\n        }\n\n        return (id, count);\n    }\n}\n"
      },
      "project/contracts/SolidityPackDecoder.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./SolidityPackTypes.sol\";\n\n/**\n * @title SolidityPackDecoder\n * @notice Ultra gas-efficient decoding for SolidityPack format\n * @dev Decoder-only library to save bytecode in contracts that only decode\n */\n\nlibrary SolidityPackDecoder {\n    using SolidityPackTypes for *;\n\n    // ============ TYPE CATEGORIES ============\n\n    enum TypeCategory {\n        NIL,\n        BOOL,\n        UINT,\n        INT,\n        BYTES,\n        STRING,\n        ARRAY,\n        MAP,\n        ADDRESS,\n        BYTES32\n    }\n\n    // ============ GENERIC TYPE INSPECTION ============\n\n    /**\n     * @notice Get the category of the next value without consuming it\n     * @dev Useful for dynamic decoding when you don't know the type ahead of time\n     */\n    function peekCategory(SolidityPackTypes.Decoder memory dec) internal pure returns (TypeCategory) {\n        require(dec.pos < dec.data.length, \"EOF\");\n        uint8 tag = uint8(dec.data[dec.pos]);\n\n        if (tag == SolidityPackTypes.NIL) {\n            return TypeCategory.NIL;\n        } else if (tag == SolidityPackTypes.TRUE || tag == SolidityPackTypes.FALSE) {\n            return TypeCategory.BOOL;\n        } else if (\n            tag <= SolidityPackTypes.FIXINT_POS_MAX ||\n            tag == SolidityPackTypes.UINT8 ||\n            tag == SolidityPackTypes.UINT16 ||\n            tag == SolidityPackTypes.UINT32 ||\n            tag == SolidityPackTypes.UINT64 ||\n            tag == SolidityPackTypes.UINT128 ||\n            tag == SolidityPackTypes.UINT256\n        ) {\n            return TypeCategory.UINT;\n        } else if (\n            tag >= SolidityPackTypes.FIXINT_NEG_BASE ||\n            tag == SolidityPackTypes.INT8 ||\n            tag == SolidityPackTypes.INT16 ||\n            tag == SolidityPackTypes.INT32 ||\n            tag == SolidityPackTypes.INT64 ||\n            tag == SolidityPackTypes.INT128 ||\n            tag == SolidityPackTypes.INT256\n        ) {\n            return TypeCategory.INT;\n        } else if (tag == SolidityPackTypes.BYTES8 || tag == SolidityPackTypes.BYTES16) {\n            return TypeCategory.BYTES;\n        } else if (\n            (tag >= SolidityPackTypes.FIXSTR_BASE && tag < SolidityPackTypes.FIXSTR_BASE + 32) ||\n            tag == SolidityPackTypes.STR8 ||\n            tag == SolidityPackTypes.STR16\n        ) {\n            return TypeCategory.STRING;\n        } else if (\n            (tag >= SolidityPackTypes.FIXARRAY_BASE && tag < SolidityPackTypes.FIXARRAY_BASE + 16) ||\n            tag == SolidityPackTypes.ARRAY8 ||\n            tag == SolidityPackTypes.ARRAY16\n        ) {\n            return TypeCategory.ARRAY;\n        } else if (\n            (tag >= SolidityPackTypes.FIXMAP_BASE && tag < SolidityPackTypes.FIXMAP_BASE + 16) ||\n            tag == SolidityPackTypes.MAP8 ||\n            tag == SolidityPackTypes.MAP16\n        ) {\n            return TypeCategory.MAP;\n        } else if (tag == SolidityPackTypes.ADDRESS) {\n            return TypeCategory.ADDRESS;\n        } else if (tag == SolidityPackTypes.BYTES32_TYPE) {\n            return TypeCategory.BYTES32;\n        }\n\n        revert(\"Unknown type tag\");\n    }\n\n    /**\n     * @notice Check if the next value is of a specific category\n     * @dev Useful for conditional decoding\n     */\n    function isCategory(\n        SolidityPackTypes.Decoder memory dec,\n        TypeCategory category\n    ) internal pure returns (bool) {\n        if (dec.pos >= dec.data.length) return false;\n        return peekCategory(dec) == category;\n    }\n\n    /**\n     * @notice Check if decoder has more data to read\n     */\n    function hasMore(SolidityPackTypes.Decoder memory dec) internal pure returns (bool) {\n        return dec.pos < dec.data.length;\n    }\n\n    // ============ DECODER FUNCTIONS ============\n\n    function newDecoder(bytes memory data) internal pure returns (SolidityPackTypes.Decoder memory) {\n        return SolidityPackTypes.Decoder(data, 0);\n    }\n\n    function peekType(SolidityPackTypes.Decoder memory dec) internal pure returns (uint8) {\n        require(dec.pos < dec.data.length, \"EOF\");\n        return uint8(dec.data[dec.pos]);\n    }\n\n    function decodeBool(SolidityPackTypes.Decoder memory dec) internal pure returns (bool) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n        require(tag == SolidityPackTypes.TRUE || tag == SolidityPackTypes.FALSE, \"Not bool\");\n        return tag == SolidityPackTypes.TRUE;\n    }\n\n    function decodeNil(SolidityPackTypes.Decoder memory dec) internal pure {\n        require(peekType(dec) == SolidityPackTypes.NIL, \"Not nil\");\n        dec.pos++;\n    }\n\n    function decodeUint(SolidityPackTypes.Decoder memory dec) internal pure returns (uint256) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        if (tag <= SolidityPackTypes.FIXINT_POS_MAX) {\n            return uint256(tag);\n        } else if (tag == SolidityPackTypes.UINT8) {\n            return uint256(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.UINT16) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := or(shl(8, byte(0, mload(ptr))), byte(0, mload(add(ptr, 1))))\n            }\n            dec.pos += 2;\n            return val;\n        } else if (tag == SolidityPackTypes.UINT32) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := or(\n                    or(\n                        or(shl(24, byte(0, mload(ptr))), shl(16, byte(0, mload(add(ptr, 1))))),\n                        shl(8, byte(0, mload(add(ptr, 2))))\n                    ),\n                    byte(0, mload(add(ptr, 3)))\n                )\n            }\n            dec.pos += 4;\n            return val;\n        } else if (tag == SolidityPackTypes.UINT64) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := 0\n                for { let i := 0 } lt(i, 8) { i := add(i, 1) } {\n                    val := or(shl(8, val), byte(0, mload(add(ptr, i))))\n                }\n            }\n            dec.pos += 8;\n            return val;\n        } else if (tag == SolidityPackTypes.UINT128) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := 0\n                for { let i := 0 } lt(i, 16) { i := add(i, 1) } {\n                    val := or(shl(8, val), byte(0, mload(add(ptr, i))))\n                }\n            }\n            dec.pos += 16;\n            return val;\n        } else if (tag == SolidityPackTypes.UINT256) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := mload(ptr)\n            }\n            dec.pos += 32;\n            return val;\n        }\n\n        revert(\"Invalid uint tag\");\n    }\n\n    function decodeInt(SolidityPackTypes.Decoder memory dec) internal pure returns (int256) {\n        uint8 tag = peekType(dec);\n\n        if (tag <= SolidityPackTypes.FIXINT_POS_MAX) {\n            dec.pos++;\n            return int256(uint256(tag));\n        } else if (tag >= SolidityPackTypes.FIXINT_NEG_BASE) {\n            dec.pos++;\n            return\n                int8(uint8(tag)) -\n                int8(uint8(SolidityPackTypes.FIXINT_NEG_BASE)) -\n                32;\n        }\n\n        dec.pos++;\n\n        if (tag == SolidityPackTypes.INT8) {\n            return int8(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.INT16) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := or(shl(8, byte(0, mload(ptr))), byte(0, mload(add(ptr, 1))))\n                // Use signextend opcode\n                val := signextend(1, val)\n            }\n            dec.pos += 2;\n            return int256(val);\n        } else if (tag == SolidityPackTypes.INT32) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := or(\n                    or(\n                        or(shl(24, byte(0, mload(ptr))), shl(16, byte(0, mload(add(ptr, 1))))),\n                        shl(8, byte(0, mload(add(ptr, 2))))\n                    ),\n                    byte(0, mload(add(ptr, 3)))\n                )\n                // Use signextend opcode\n                val := signextend(3, val)\n            }\n            dec.pos += 4;\n            return int256(val);\n        } else if (tag == SolidityPackTypes.INT256) {\n            int256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := mload(ptr)\n            }\n            dec.pos += 32;\n            return val;\n        }\n\n        revert(\"Invalid int tag\");\n    }\n\n    function decodeAddress(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (address) {\n        require(peekType(dec) == SolidityPackTypes.ADDRESS, \"Not address\");\n        dec.pos++;\n        address val;\n        assembly {\n            let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n            val := shr(96, mload(ptr))\n        }\n        dec.pos += 20;\n        return val;\n    }\n\n    function decodeBytes32(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (bytes32) {\n        require(peekType(dec) == SolidityPackTypes.BYTES32_TYPE, \"Not bytes32\");\n        dec.pos++;\n        bytes32 val;\n        assembly {\n            let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n            val := mload(ptr)\n        }\n        dec.pos += 32;\n        return val;\n    }\n\n    function decodeBytes(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (bytes memory) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        uint256 len;\n        if (tag == SolidityPackTypes.BYTES8) {\n            len = uint256(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.BYTES16) {\n            len =\n                (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n        } else {\n            revert(\"Not bytes\");\n        }\n\n        bytes memory result = new bytes(len);\n        assembly {\n            let src := add(add(mload(dec), 32), mload(add(dec, 32)))\n            let dst := add(result, 32)\n\n            // Copy full 32-byte chunks\n            let fullChunks := div(len, 32)\n            for { let i := 0 } lt(i, fullChunks) { i := add(i, 1) } {\n                mstore(add(dst, mul(i, 32)), mload(add(src, mul(i, 32))))\n            }\n\n            // Copy remaining bytes if any\n            let remaining := mod(len, 32)\n            if gt(remaining, 0) {\n                let lastChunkOffset := mul(fullChunks, 32)\n                let mask := sub(shl(mul(remaining, 8), 1), 1)\n                let srcData := and(\n                    mload(add(src, lastChunkOffset)),\n                    shl(sub(256, mul(remaining, 8)), mask)\n                )\n                mstore(add(dst, lastChunkOffset), srcData)\n            }\n        }\n        dec.pos += len;\n        return result;\n    }\n\n    function decodeString(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (string memory) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        uint256 len;\n        if (tag >= SolidityPackTypes.FIXSTR_BASE && tag < SolidityPackTypes.FIXSTR_BASE + 32) {\n            len = uint256(tag - SolidityPackTypes.FIXSTR_BASE);\n        } else if (tag == SolidityPackTypes.STR8) {\n            len = uint256(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.STR16) {\n            len =\n                (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n        } else {\n            revert(\"Not string\");\n        }\n\n        bytes memory result = new bytes(len);\n        assembly {\n            let src := add(add(mload(dec), 32), mload(add(dec, 32)))\n            let dst := add(result, 32)\n\n            // Copy full 32-byte chunks\n            let fullChunks := div(len, 32)\n            for { let i := 0 } lt(i, fullChunks) { i := add(i, 1) } {\n                mstore(add(dst, mul(i, 32)), mload(add(src, mul(i, 32))))\n            }\n\n            // Copy remaining bytes if any\n            let remaining := mod(len, 32)\n            if gt(remaining, 0) {\n                let lastChunkOffset := mul(fullChunks, 32)\n                let mask := sub(shl(mul(remaining, 8), 1), 1)\n                let srcData := and(\n                    mload(add(src, lastChunkOffset)),\n                    shl(sub(256, mul(remaining, 8)), mask)\n                )\n                mstore(add(dst, lastChunkOffset), srcData)\n            }\n        }\n        dec.pos += len;\n        return string(result);\n    }\n\n    function decodeArrayLength(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (uint256) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        if (tag >= SolidityPackTypes.FIXARRAY_BASE && tag < SolidityPackTypes.FIXARRAY_BASE + 16) {\n            return uint256(tag - SolidityPackTypes.FIXARRAY_BASE);\n        } else if (tag == SolidityPackTypes.ARRAY8) {\n            return uint256(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.ARRAY16) {\n            uint256 len = (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n            return len;\n        }\n\n        revert(\"Not array\");\n    }\n\n    function decodeMapLength(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (uint256) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        if (tag >= SolidityPackTypes.FIXMAP_BASE && tag < SolidityPackTypes.FIXMAP_BASE + 16) {\n            return uint256(tag - SolidityPackTypes.FIXMAP_BASE);\n        } else if (tag == SolidityPackTypes.MAP8) {\n            return uint256(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.MAP16) {\n            uint256 len = (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n            return len;\n        }\n\n        revert(\"Not map\");\n    }\n\n    // ============ NESTED OBJECT DECODING ============\n\n    /**\n     * @notice Start decoding a nested object (map)\n     * @return Number of key-value pairs\n     */\n    function decodeObjectLength(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (uint256) {\n        return decodeMapLength(dec);\n    }\n\n    /**\n     * @notice Helper to decode array of uints\n     */\n    function decodeUintArray(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (uint256[] memory) {\n        uint256 len = decodeArrayLength(dec);\n        uint256[] memory result = new uint256[](len);\n        for (uint256 i = 0; i < len; i++) {\n            result[i] = decodeUint(dec);\n        }\n        return result;\n    }\n\n    /**\n     * @notice Helper to decode array of addresses\n     */\n    function decodeAddressArray(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (address[] memory) {\n        uint256 len = decodeArrayLength(dec);\n        address[] memory result = new address[](len);\n        for (uint256 i = 0; i < len; i++) {\n            result[i] = decodeAddress(dec);\n        }\n        return result;\n    }\n\n    /**\n     * @notice Helper to decode array of strings\n     */\n    function decodeStringArray(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (string[] memory) {\n        uint256 len = decodeArrayLength(dec);\n        string[] memory result = new string[](len);\n        for (uint256 i = 0; i < len; i++) {\n            result[i] = decodeString(dec);\n        }\n        return result;\n    }\n\n    /**\n     * @notice Skip the next value in the decoder (useful for unknown fields)\n     */\n    function skip(SolidityPackTypes.Decoder memory dec) internal pure {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        // Handle different type categories\n        if (tag <= SolidityPackTypes.FIXINT_POS_MAX || tag >= SolidityPackTypes.FIXINT_NEG_BASE) {\n            // Fixint, already consumed\n            return;\n        } else if (\n            tag >= SolidityPackTypes.FIXSTR_BASE && tag < SolidityPackTypes.FIXSTR_BASE + 32\n        ) {\n            // Fixstr\n            dec.pos += (tag - SolidityPackTypes.FIXSTR_BASE);\n        } else if (\n            tag >= SolidityPackTypes.FIXARRAY_BASE && tag < SolidityPackTypes.FIXARRAY_BASE + 16\n        ) {\n            // Fixarray\n            uint256 len = tag - SolidityPackTypes.FIXARRAY_BASE;\n            for (uint256 i = 0; i < len; i++) {\n                skip(dec);\n            }\n        } else if (\n            tag >= SolidityPackTypes.FIXMAP_BASE && tag < SolidityPackTypes.FIXMAP_BASE + 16\n        ) {\n            // Fixmap\n            uint256 len = tag - SolidityPackTypes.FIXMAP_BASE;\n            for (uint256 i = 0; i < len * 2; i++) {\n                skip(dec);\n            }\n        } else if (\n            tag == SolidityPackTypes.NIL ||\n            tag == SolidityPackTypes.TRUE ||\n            tag == SolidityPackTypes.FALSE\n        ) {\n            // Already consumed\n        } else if (tag == SolidityPackTypes.UINT8 || tag == SolidityPackTypes.INT8) {\n            dec.pos += 1;\n        } else if (tag == SolidityPackTypes.UINT16 || tag == SolidityPackTypes.INT16) {\n            dec.pos += 2;\n        } else if (tag == SolidityPackTypes.UINT32 || tag == SolidityPackTypes.INT32) {\n            dec.pos += 4;\n        } else if (tag == SolidityPackTypes.UINT64 || tag == SolidityPackTypes.INT64) {\n            dec.pos += 8;\n        } else if (tag == SolidityPackTypes.UINT128 || tag == SolidityPackTypes.INT128) {\n            dec.pos += 16;\n        } else if (\n            tag == SolidityPackTypes.UINT256 ||\n            tag == SolidityPackTypes.INT256 ||\n            tag == SolidityPackTypes.BYTES32_TYPE\n        ) {\n            dec.pos += 32;\n        } else if (tag == SolidityPackTypes.ADDRESS) {\n            dec.pos += 20;\n        } else if (tag == SolidityPackTypes.BYTES8 || tag == SolidityPackTypes.STR8) {\n            uint256 len = uint256(uint8(dec.data[dec.pos++]));\n            dec.pos += len;\n        } else if (tag == SolidityPackTypes.BYTES16 || tag == SolidityPackTypes.STR16) {\n            uint256 len = (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2 + len;\n        } else if (tag == SolidityPackTypes.ARRAY8) {\n            uint256 len = uint256(uint8(dec.data[dec.pos++]));\n            for (uint256 i = 0; i < len; i++) {\n                skip(dec);\n            }\n        } else if (tag == SolidityPackTypes.ARRAY16) {\n            uint256 len = (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n            for (uint256 i = 0; i < len; i++) {\n                skip(dec);\n            }\n        } else if (tag == SolidityPackTypes.MAP8) {\n            uint256 len = uint256(uint8(dec.data[dec.pos++]));\n            for (uint256 i = 0; i < len * 2; i++) {\n                skip(dec);\n            }\n        } else if (tag == SolidityPackTypes.MAP16) {\n            uint256 len = (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n            for (uint256 i = 0; i < len * 2; i++) {\n                skip(dec);\n            }\n        } else {\n            revert(\"Unknown type tag\");\n        }\n    }\n}\n"
      },
      "project/contracts/SolidityPackEncoder.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./SolidityPackTypes.sol\";\n\n/**\n * @title SolidityPackEncoder\n * @notice Ultra gas-efficient encoding for SolidityPack format\n * @dev Encoder-only library to save bytecode in contracts that only encode\n */\n\nlibrary SolidityPackEncoder {\n    using SolidityPackTypes for *;\n\n    // ============ ENCODER FUNCTIONS ============\n\n    function newEncoder() internal pure returns (SolidityPackTypes.Encoder memory) {\n        return SolidityPackTypes.Encoder(\n            new bytes(SolidityPackTypes.INITIAL_BUFFER_SIZE),\n            0\n        );\n    }\n\n    function encodeBool(\n        SolidityPackTypes.Encoder memory enc,\n        bool value\n    ) internal pure returns (SolidityPackTypes.Encoder memory) {\n        _ensureCapacity(enc, 1);\n        enc.buffer[enc.pos++] = bytes1(value ? SolidityPackTypes.TRUE : SolidityPackTypes.FALSE);\n        return enc;\n    }\n\n    function encodeNil(\n        SolidityPackTypes.Encoder memory enc\n    ) internal pure returns (SolidityPackTypes.Encoder memory) {\n        _ensureCapacity(enc, 1);\n        enc.buffer[enc.pos++] = bytes1(SolidityPackTypes.NIL);\n        return enc;\n    }\n\n    function encodeUint(\n        SolidityPackTypes.Encoder memory enc,\n        uint256 value\n    ) internal pure returns (SolidityPackTypes.Encoder memory) {\n        if (value <= SolidityPackTypes.FIXINT_POS_MAX) {\n            _ensureCapacity(enc, 1);\n            enc.buffer[enc.pos++] = bytes1(uint8(value));\n        } else if (value <= type(uint8).max) {\n            _ensureCapacity(enc, 2);\n            enc.buffer[enc.pos++] = bytes1(SolidityPackTypes.UINT8);\n            enc.buffer[enc.pos++] = bytes1(uint8(value));\n        } else if (value <= type(uint16).max) {\n            _ensureCapacity(enc, 3);\n            enc.buffer[enc.pos++] = bytes1(SolidityPackTypes.UINT16);\n            assembly {\n                let ptr := add(add(mload(enc), 32), mload(add(enc, 32)))\n                mstore8(ptr, shr(8, value))\n                mstore8(add(ptr, 1), value)\n            }\n            enc.pos += 2;\n        } else if (value <= type(uint32).max) {\n            _ensureCapacity(enc, 5);\n            enc.buffer[enc.pos++] = bytes1(SolidityPackTypes.UINT32);\n            assembly {\n                let ptr := add(add(mload(enc), 32), mload(add(enc, 32)))\n                mstore8(ptr, shr(24, value))\n                mstore8(add(ptr, 1), shr(16, value))\n                mstore8(add(ptr, 2), shr(8, value))\n                mstore8(add(ptr, 3), value)\n            }\n            enc.pos += 4;\n        } else if (value <= type(uint64).max) {\n            _ensureCapacity(enc, 9);\n            enc.buffer[enc.pos++] = bytes1(SolidityPackTypes.UINT64);\n            assembly {\n                let ptr := add(add(mload(enc), 32), mload(add(enc, 32)))\n                mstore8(ptr, shr(56, value))\n                mstore8(add(ptr, 1), shr(48, value))\n                mstore8(add(ptr, 2), shr(40, value))\n                mstore8(add(ptr, 3), shr(32, value))\n                mstore8(add(ptr, 4), shr(24, value))\n                mstore8(add(ptr, 5), shr(16, value))\n                mstore8(add(ptr, 6), shr(8, value))\n                mstore8(add(ptr, 7), value)\n            }\n            enc.pos += 8;\n        } else if (value <= type(uint128).max) {\n            _ensureCapacity(enc, 17);\n            enc.buffer[enc.pos++] = bytes1(SolidityPackTypes.UINT128);\n            assembly {\n                let ptr := add(add(mload(enc), 32), mload(add(enc, 32)))\n                for { let i := 0 } lt(i, 16) { i := add(i, 1) } {\n                    mstore8(add(ptr, i), shr(sub(120, mul(i, 8)), value))\n                }\n            }\n            enc.pos += 16;\n        } else {\n            _ensureCapacity(enc, 33);\n            enc.buffer[enc.pos++] = bytes1(SolidityPackTypes.UINT256);\n            assembly {\n                let ptr := add(add(mload(enc), 32), mload(add(enc, 32)))\n                mstore(ptr, value)\n            }\n            enc.pos += 32;\n        }\n        return enc;\n    }\n\n    function encodeInt(\n        SolidityPackTypes.Encoder memory enc,\n        int256 value\n    ) internal pure returns (SolidityPackTypes.Encoder memory) {\n        if (value >= 0) {\n            return encodeUint(enc, uint256(value));\n        }\n\n        if (value >= -32) {\n            _ensureCapacity(enc, 1);\n            enc.buffer[enc.pos++] = bytes1(\n                uint8(SolidityPackTypes.FIXINT_NEG_BASE + uint8(int8(value + 32)))\n            );\n        } else if (value >= type(int8).min) {\n            _ensureCapacity(enc, 2);\n            enc.buffer[enc.pos++] = bytes1(SolidityPackTypes.INT8);\n            enc.buffer[enc.pos++] = bytes1(uint8(int8(value)));\n        } else if (value >= type(int16).min) {\n            _ensureCapacity(enc, 3);\n            enc.buffer[enc.pos++] = bytes1(SolidityPackTypes.INT16);\n            assembly {\n                let ptr := add(add(mload(enc), 32), mload(add(enc, 32)))\n                mstore8(ptr, shr(8, value))\n                mstore8(add(ptr, 1), value)\n            }\n            enc.pos += 2;\n        } else if (value >= type(int32).min) {\n            _ensureCapacity(enc, 5);\n            enc.buffer[enc.pos++] = bytes1(SolidityPackTypes.INT32);\n            assembly {\n                let ptr := add(add(mload(enc), 32), mload(add(enc, 32)))\n                mstore8(ptr, shr(24, value))\n                mstore8(add(ptr, 1), shr(16, value))\n                mstore8(add(ptr, 2), shr(8, value))\n                mstore8(add(ptr, 3), value)\n            }\n            enc.pos += 4;\n        } else {\n            _ensureCapacity(enc, 33);\n            enc.buffer[enc.pos++] = bytes1(SolidityPackTypes.INT256);\n            assembly {\n                let ptr := add(add(mload(enc), 32), mload(add(enc, 32)))\n                mstore(ptr, value)\n            }\n            enc.pos += 32;\n        }\n        return enc;\n    }\n\n    function encodeAddress(\n        SolidityPackTypes.Encoder memory enc,\n        address value\n    ) internal pure returns (SolidityPackTypes.Encoder memory) {\n        _ensureCapacity(enc, 21);\n        enc.buffer[enc.pos++] = bytes1(SolidityPackTypes.ADDRESS);\n        assembly {\n            let ptr := add(add(mload(enc), 32), mload(add(enc, 32)))\n            mstore(ptr, shl(96, value))\n        }\n        enc.pos += 20;\n        return enc;\n    }\n\n    function encodeBytes32(\n        SolidityPackTypes.Encoder memory enc,\n        bytes32 value\n    ) internal pure returns (SolidityPackTypes.Encoder memory) {\n        _ensureCapacity(enc, 33);\n        enc.buffer[enc.pos++] = bytes1(SolidityPackTypes.BYTES32_TYPE);\n        assembly {\n            let ptr := add(add(mload(enc), 32), mload(add(enc, 32)))\n            mstore(ptr, value)\n        }\n        enc.pos += 32;\n        return enc;\n    }\n\n    function encodeBytes(\n        SolidityPackTypes.Encoder memory enc,\n        bytes memory value\n    ) internal pure returns (SolidityPackTypes.Encoder memory) {\n        uint256 len = value.length;\n        if (len <= 255) {\n            _ensureCapacity(enc, len + 2);\n            enc.buffer[enc.pos++] = bytes1(SolidityPackTypes.BYTES8);\n            enc.buffer[enc.pos++] = bytes1(uint8(len));\n        } else {\n            _ensureCapacity(enc, len + 3);\n            enc.buffer[enc.pos++] = bytes1(SolidityPackTypes.BYTES16);\n            enc.buffer[enc.pos++] = bytes1(uint8(len >> 8));\n            enc.buffer[enc.pos++] = bytes1(uint8(len));\n        }\n\n        // Proper memory copying with tail handling\n        assembly {\n            let src := add(value, 32)\n            let dst := add(add(mload(enc), 32), mload(add(enc, 32)))\n            let remaining := len\n\n            // Copy 32-byte chunks\n            for { let i := 0 } lt(i, len) { i := add(i, 32) } {\n                mstore(add(dst, i), mload(add(src, i)))\n            }\n        }\n        enc.pos += len;\n        return enc;\n    }\n\n    function encodeString(\n        SolidityPackTypes.Encoder memory enc,\n        string memory value\n    ) internal pure returns (SolidityPackTypes.Encoder memory) {\n        bytes memory b = bytes(value);\n        uint256 len = b.length;\n\n        if (len <= 31) {\n            _ensureCapacity(enc, len + 1);\n            enc.buffer[enc.pos++] = bytes1(uint8(SolidityPackTypes.FIXSTR_BASE + len));\n        } else if (len <= 255) {\n            _ensureCapacity(enc, len + 2);\n            enc.buffer[enc.pos++] = bytes1(SolidityPackTypes.STR8);\n            enc.buffer[enc.pos++] = bytes1(uint8(len));\n        } else {\n            _ensureCapacity(enc, len + 3);\n            enc.buffer[enc.pos++] = bytes1(SolidityPackTypes.STR16);\n            enc.buffer[enc.pos++] = bytes1(uint8(len >> 8));\n            enc.buffer[enc.pos++] = bytes1(uint8(len));\n        }\n\n        // Same safe copying approach\n        assembly {\n            let src := add(b, 32)\n            let dst := add(add(mload(enc), 32), mload(add(enc, 32)))\n            for { let i := 0 } lt(i, len) { i := add(i, 32) } {\n                mstore(add(dst, i), mload(add(src, i)))\n            }\n        }\n        enc.pos += len;\n        return enc;\n    }\n\n    function startArray(\n        SolidityPackTypes.Encoder memory enc,\n        uint256 length\n    ) internal pure returns (SolidityPackTypes.Encoder memory) {\n        if (length <= 15) {\n            _ensureCapacity(enc, 1);\n            enc.buffer[enc.pos++] = bytes1(uint8(SolidityPackTypes.FIXARRAY_BASE + length));\n        } else if (length <= 255) {\n            _ensureCapacity(enc, 2);\n            enc.buffer[enc.pos++] = bytes1(SolidityPackTypes.ARRAY8);\n            enc.buffer[enc.pos++] = bytes1(uint8(length));\n        } else {\n            _ensureCapacity(enc, 3);\n            enc.buffer[enc.pos++] = bytes1(SolidityPackTypes.ARRAY16);\n            enc.buffer[enc.pos++] = bytes1(uint8(length >> 8));\n            enc.buffer[enc.pos++] = bytes1(uint8(length));\n        }\n        return enc;\n    }\n\n    function startMap(\n        SolidityPackTypes.Encoder memory enc,\n        uint256 length\n    ) internal pure returns (SolidityPackTypes.Encoder memory) {\n        if (length <= 15) {\n            _ensureCapacity(enc, 1);\n            enc.buffer[enc.pos++] = bytes1(uint8(SolidityPackTypes.FIXMAP_BASE + length));\n        } else if (length <= 255) {\n            _ensureCapacity(enc, 2);\n            enc.buffer[enc.pos++] = bytes1(SolidityPackTypes.MAP8);\n            enc.buffer[enc.pos++] = bytes1(uint8(length));\n        } else {\n            _ensureCapacity(enc, 3);\n            enc.buffer[enc.pos++] = bytes1(SolidityPackTypes.MAP16);\n            enc.buffer[enc.pos++] = bytes1(uint8(length >> 8));\n            enc.buffer[enc.pos++] = bytes1(uint8(length));\n        }\n        return enc;\n    }\n\n    // ============ NESTED OBJECT SUPPORT ============\n\n    /**\n     * @notice Start encoding a nested object (map with string keys)\n     * @dev Call this, then encode key-value pairs using encodeKey/encode* pattern\n     */\n    function startObject(\n        SolidityPackTypes.Encoder memory enc,\n        uint256 numFields\n    ) internal pure returns (SolidityPackTypes.Encoder memory) {\n        return startMap(enc, numFields);\n    }\n\n    /**\n     * @notice Encode a field key in an object\n     * @dev Optimized for short field names\n     */\n    function encodeKey(\n        SolidityPackTypes.Encoder memory enc,\n        string memory key\n    ) internal pure returns (SolidityPackTypes.Encoder memory) {\n        return encodeString(enc, key);\n    }\n\n    /**\n     * @notice Helper to encode nested array of uints\n     */\n    function encodeUintArray(\n        SolidityPackTypes.Encoder memory enc,\n        uint256[] memory values\n    ) internal pure returns (SolidityPackTypes.Encoder memory) {\n        startArray(enc, values.length);\n        for (uint256 i = 0; i < values.length; i++) {\n            encodeUint(enc, values[i]);\n        }\n        return enc;\n    }\n\n    /**\n     * @notice Helper to encode nested array of addresses\n     */\n    function encodeAddressArray(\n        SolidityPackTypes.Encoder memory enc,\n        address[] memory values\n    ) internal pure returns (SolidityPackTypes.Encoder memory) {\n        startArray(enc, values.length);\n        for (uint256 i = 0; i < values.length; i++) {\n            encodeAddress(enc, values[i]);\n        }\n        return enc;\n    }\n\n    /**\n     * @notice Helper to encode nested array of strings\n     */\n    function encodeStringArray(\n        SolidityPackTypes.Encoder memory enc,\n        string[] memory values\n    ) internal pure returns (SolidityPackTypes.Encoder memory) {\n        startArray(enc, values.length);\n        for (uint256 i = 0; i < values.length; i++) {\n            encodeString(enc, values[i]);\n        }\n        return enc;\n    }\n\n    function getEncoded(\n        SolidityPackTypes.Encoder memory enc\n    ) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(enc.pos);\n        assembly {\n            let src := add(mload(enc), 32)\n            let dst := add(result, 32)\n            // Safe to copy in 32-byte chunks as long as we only copy enc.pos bytes total\n            let remaining := mload(add(enc, 32))\n            for { let i := 0 } lt(i, remaining) { i := add(i, 32) } {\n                mstore(add(dst, i), mload(add(src, i)))\n            }\n        }\n        return result;\n    }\n\n    // ============ INTERNAL HELPERS ============\n\n    function _ensureCapacity(\n        SolidityPackTypes.Encoder memory enc,\n        uint256 required\n    ) private pure {\n        uint256 needed = enc.pos + required;\n        if (needed <= enc.buffer.length) return;\n\n        uint256 currentSize = enc.buffer.length;\n        uint256 newSize;\n\n        if (currentSize < SolidityPackTypes.GROWTH_THRESHOLD) {\n            newSize = (currentSize * 3) / 2;\n            if (newSize < needed) {\n                newSize = needed;\n            }\n            newSize += SolidityPackTypes.MIN_GROWTH_MARGIN;\n        } else {\n            uint256 growth = needed - currentSize;\n            uint256 margin = growth / 4;\n            if (margin < SolidityPackTypes.MIN_GROWTH_MARGIN) {\n                margin = SolidityPackTypes.MIN_GROWTH_MARGIN;\n            }\n            newSize = needed + margin;\n        }\n\n        bytes memory newBuffer = new bytes(newSize);\n        assembly {\n            let src := add(mload(enc), 32)\n            let dst := add(newBuffer, 32)\n            let len := mload(add(enc, 32))\n\n            for { let i := 0 } lt(i, len) { i := add(i, 32) } {\n                mstore(add(dst, i), mload(add(src, i)))\n            }\n        }\n        enc.buffer = newBuffer;\n    }\n}\n"
      },
      "project/contracts/SolidityPackTypes.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title SolidityPackTypes\n * @notice Shared type constants and structs for SolidityPack encoding/decoding\n * @dev This library contains only constants and is optimized away at compile time\n */\n\nlibrary SolidityPackTypes {\n\n    // Type constants\n    uint8 internal constant FIXINT_POS_MAX = 0x7F;\n    uint8 internal constant FIXMAP_BASE = 0x80;\n    uint8 internal constant FIXARRAY_BASE = 0x90;\n    uint8 internal constant FIXSTR_BASE = 0xA0;\n    uint8 internal constant NIL = 0xC0;\n    uint8 internal constant FALSE = 0xC2;\n    uint8 internal constant TRUE = 0xC3;\n    uint8 internal constant UINT8 = 0xC4;\n    uint8 internal constant UINT16 = 0xC5;\n    uint8 internal constant UINT32 = 0xC6;\n    uint8 internal constant UINT64 = 0xC7;\n    uint8 internal constant UINT128 = 0xC8;\n    uint8 internal constant UINT256 = 0xC9;\n    uint8 internal constant INT8 = 0xCA;\n    uint8 internal constant INT16 = 0xCB;\n    uint8 internal constant INT32 = 0xCC;\n    uint8 internal constant INT64 = 0xCD;\n    uint8 internal constant INT128 = 0xCE;\n    uint8 internal constant INT256 = 0xCF;\n    uint8 internal constant BYTES8 = 0xD0;\n    uint8 internal constant BYTES16 = 0xD1;\n    uint8 internal constant STR8 = 0xD2;\n    uint8 internal constant STR16 = 0xD3;\n    uint8 internal constant ADDRESS = 0xD4;\n    uint8 internal constant BYTES32_TYPE = 0xD5;\n    uint8 internal constant ARRAY8 = 0xD6;\n    uint8 internal constant ARRAY16 = 0xD7;\n    uint8 internal constant MAP8 = 0xD8;\n    uint8 internal constant MAP16 = 0xD9;\n    uint8 internal constant FIXINT_NEG_BASE = 0xE0;\n\n    // Growth strategy constants for encoder\n    uint256 internal constant INITIAL_BUFFER_SIZE = 256;\n    uint256 internal constant GROWTH_THRESHOLD = 4096;\n    uint256 internal constant MIN_GROWTH_MARGIN = 128;\n\n    // Encoder struct\n    struct Encoder {\n        bytes buffer;\n        uint256 pos;\n    }\n\n    // Decoder struct\n    struct Decoder {\n        bytes data;\n        uint256 pos;\n    }\n}\n"
      },
      "project/contracts/test/NestedStructuresTest.t.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../examples/NestedStructuresExample.sol\";\n\n/**\n * @title NestedStructuresTest\n * @notice Test nested structure encoding and decoding\n */\ncontract NestedStructuresTest {\n    NestedStructuresExample example;\n\n    constructor() {\n        example = new NestedStructuresExample();\n    }\n\n    function testEncodeNestedMap() public view returns (bytes memory) {\n        return example.encodeNestedMap();\n    }\n\n    function testEncodeMapWithArray() public view returns (bytes memory) {\n        return example.encodeMapWithArray();\n    }\n\n    function testEncodeComplexNesting() public view returns (bytes memory) {\n        return example.encodeComplexNesting();\n    }\n\n    function testDecodeNestedMapStepByStep() public view returns (\n        uint256 outerValue,\n        uint256 nestedInner,\n        string memory nestedName\n    ) {\n        return example.decodeNestedMapStepByStep();\n    }\n\n    function testDecodeMapWithArrayUsingInspection() public view returns (\n        string memory name,\n        uint256 firstScore,\n        uint256 scoresCount\n    ) {\n        return example.decodeMapWithArrayUsingInspection();\n    }\n\n    function testDecodeComplexAndExtractTags() public view returns (\n        string memory firstTag,\n        string memory secondTag,\n        bool foundTags\n    ) {\n        return example.decodeComplexAndExtractTags();\n    }\n\n    function testDecodeUnknownStructureWithSkip() public view returns (\n        uint256 id,\n        uint256 count\n    ) {\n        return example.decodeUnknownStructureWithSkip();\n    }\n}\n"
      }
    }
  }
}