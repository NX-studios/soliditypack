{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-7255bbcf9c08de0cda33ffd47dee90d1fe07a449",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/test/DecoderTest.t.sol": "project/contracts/test/DecoderTest.t.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/SolidityPackDecoder.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./SolidityPackTypes.sol\";\n\n/**\n * @title SolidityPackDecoder\n * @notice Ultra gas-efficient decoding for SolidityPack format\n * @dev Decoder-only library to save bytecode in contracts that only decode\n */\n\nlibrary SolidityPackDecoder {\n    using SolidityPackTypes for *;\n\n    // ============ TYPE CATEGORIES ============\n\n    enum TypeCategory {\n        NIL,\n        BOOL,\n        UINT,\n        INT,\n        BYTES,\n        STRING,\n        ARRAY,\n        MAP,\n        ADDRESS,\n        BYTES32\n    }\n\n    // ============ GENERIC TYPE INSPECTION ============\n\n    /**\n     * @notice Get the category of the next value without consuming it\n     * @dev Useful for dynamic decoding when you don't know the type ahead of time\n     */\n    function peekCategory(SolidityPackTypes.Decoder memory dec) internal pure returns (TypeCategory) {\n        require(dec.pos < dec.data.length, \"EOF\");\n        uint8 tag = uint8(dec.data[dec.pos]);\n\n        if (tag == SolidityPackTypes.NIL) {\n            return TypeCategory.NIL;\n        } else if (tag == SolidityPackTypes.TRUE || tag == SolidityPackTypes.FALSE) {\n            return TypeCategory.BOOL;\n        } else if (\n            tag <= SolidityPackTypes.FIXINT_POS_MAX ||\n            tag == SolidityPackTypes.UINT8 ||\n            tag == SolidityPackTypes.UINT16 ||\n            tag == SolidityPackTypes.UINT32 ||\n            tag == SolidityPackTypes.UINT64 ||\n            tag == SolidityPackTypes.UINT128 ||\n            tag == SolidityPackTypes.UINT256\n        ) {\n            return TypeCategory.UINT;\n        } else if (\n            tag >= SolidityPackTypes.FIXINT_NEG_BASE ||\n            tag == SolidityPackTypes.INT8 ||\n            tag == SolidityPackTypes.INT16 ||\n            tag == SolidityPackTypes.INT32 ||\n            tag == SolidityPackTypes.INT64 ||\n            tag == SolidityPackTypes.INT128 ||\n            tag == SolidityPackTypes.INT256\n        ) {\n            return TypeCategory.INT;\n        } else if (tag == SolidityPackTypes.BYTES8 || tag == SolidityPackTypes.BYTES16) {\n            return TypeCategory.BYTES;\n        } else if (\n            (tag >= SolidityPackTypes.FIXSTR_BASE && tag < SolidityPackTypes.FIXSTR_BASE + 32) ||\n            tag == SolidityPackTypes.STR8 ||\n            tag == SolidityPackTypes.STR16\n        ) {\n            return TypeCategory.STRING;\n        } else if (\n            (tag >= SolidityPackTypes.FIXARRAY_BASE && tag < SolidityPackTypes.FIXARRAY_BASE + 16) ||\n            tag == SolidityPackTypes.ARRAY8 ||\n            tag == SolidityPackTypes.ARRAY16\n        ) {\n            return TypeCategory.ARRAY;\n        } else if (\n            (tag >= SolidityPackTypes.FIXMAP_BASE && tag < SolidityPackTypes.FIXMAP_BASE + 16) ||\n            tag == SolidityPackTypes.MAP8 ||\n            tag == SolidityPackTypes.MAP16\n        ) {\n            return TypeCategory.MAP;\n        } else if (tag == SolidityPackTypes.ADDRESS) {\n            return TypeCategory.ADDRESS;\n        } else if (tag == SolidityPackTypes.BYTES32_TYPE) {\n            return TypeCategory.BYTES32;\n        }\n\n        revert(\"Unknown type tag\");\n    }\n\n    /**\n     * @notice Check if the next value is of a specific category\n     * @dev Useful for conditional decoding\n     */\n    function isCategory(\n        SolidityPackTypes.Decoder memory dec,\n        TypeCategory category\n    ) internal pure returns (bool) {\n        if (dec.pos >= dec.data.length) return false;\n        return peekCategory(dec) == category;\n    }\n\n    /**\n     * @notice Check if decoder has more data to read\n     */\n    function hasMore(SolidityPackTypes.Decoder memory dec) internal pure returns (bool) {\n        return dec.pos < dec.data.length;\n    }\n\n    // ============ DECODER FUNCTIONS ============\n\n    function newDecoder(bytes memory data) internal pure returns (SolidityPackTypes.Decoder memory) {\n        return SolidityPackTypes.Decoder(data, 0);\n    }\n\n    function peekType(SolidityPackTypes.Decoder memory dec) internal pure returns (uint8) {\n        require(dec.pos < dec.data.length, \"EOF\");\n        return uint8(dec.data[dec.pos]);\n    }\n\n    function decodeBool(SolidityPackTypes.Decoder memory dec) internal pure returns (bool) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n        require(tag == SolidityPackTypes.TRUE || tag == SolidityPackTypes.FALSE, \"Not bool\");\n        return tag == SolidityPackTypes.TRUE;\n    }\n\n    function decodeNil(SolidityPackTypes.Decoder memory dec) internal pure {\n        require(peekType(dec) == SolidityPackTypes.NIL, \"Not nil\");\n        dec.pos++;\n    }\n\n    function decodeUint(SolidityPackTypes.Decoder memory dec) internal pure returns (uint256) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        if (tag <= SolidityPackTypes.FIXINT_POS_MAX) {\n            return uint256(tag);\n        } else if (tag == SolidityPackTypes.UINT8) {\n            return uint256(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.UINT16) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := or(shl(8, byte(0, mload(ptr))), byte(0, mload(add(ptr, 1))))\n            }\n            dec.pos += 2;\n            return val;\n        } else if (tag == SolidityPackTypes.UINT32) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := or(\n                    or(\n                        or(shl(24, byte(0, mload(ptr))), shl(16, byte(0, mload(add(ptr, 1))))),\n                        shl(8, byte(0, mload(add(ptr, 2))))\n                    ),\n                    byte(0, mload(add(ptr, 3)))\n                )\n            }\n            dec.pos += 4;\n            return val;\n        } else if (tag == SolidityPackTypes.UINT64) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := 0\n                for { let i := 0 } lt(i, 8) { i := add(i, 1) } {\n                    val := or(shl(8, val), byte(0, mload(add(ptr, i))))\n                }\n            }\n            dec.pos += 8;\n            return val;\n        } else if (tag == SolidityPackTypes.UINT128) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := 0\n                for { let i := 0 } lt(i, 16) { i := add(i, 1) } {\n                    val := or(shl(8, val), byte(0, mload(add(ptr, i))))\n                }\n            }\n            dec.pos += 16;\n            return val;\n        } else if (tag == SolidityPackTypes.UINT256) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := mload(ptr)\n            }\n            dec.pos += 32;\n            return val;\n        }\n\n        revert(\"Invalid uint tag\");\n    }\n\n    function decodeInt(SolidityPackTypes.Decoder memory dec) internal pure returns (int256) {\n        uint8 tag = peekType(dec);\n\n        if (tag <= SolidityPackTypes.FIXINT_POS_MAX) {\n            dec.pos++;\n            return int256(uint256(tag));\n        } else if (tag >= SolidityPackTypes.FIXINT_NEG_BASE) {\n            dec.pos++;\n            return\n                int8(uint8(tag)) -\n                int8(uint8(SolidityPackTypes.FIXINT_NEG_BASE)) -\n                32;\n        }\n\n        dec.pos++;\n\n        if (tag == SolidityPackTypes.INT8) {\n            return int8(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.INT16) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := or(shl(8, byte(0, mload(ptr))), byte(0, mload(add(ptr, 1))))\n                // Use signextend opcode\n                val := signextend(1, val)\n            }\n            dec.pos += 2;\n            return int256(val);\n        } else if (tag == SolidityPackTypes.INT32) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := or(\n                    or(\n                        or(shl(24, byte(0, mload(ptr))), shl(16, byte(0, mload(add(ptr, 1))))),\n                        shl(8, byte(0, mload(add(ptr, 2))))\n                    ),\n                    byte(0, mload(add(ptr, 3)))\n                )\n                // Use signextend opcode\n                val := signextend(3, val)\n            }\n            dec.pos += 4;\n            return int256(val);\n        } else if (tag == SolidityPackTypes.INT256) {\n            int256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := mload(ptr)\n            }\n            dec.pos += 32;\n            return val;\n        }\n\n        revert(\"Invalid int tag\");\n    }\n\n    function decodeAddress(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (address) {\n        require(peekType(dec) == SolidityPackTypes.ADDRESS, \"Not address\");\n        dec.pos++;\n        address val;\n        assembly {\n            let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n            val := shr(96, mload(ptr))\n        }\n        dec.pos += 20;\n        return val;\n    }\n\n    function decodeBytes32(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (bytes32) {\n        require(peekType(dec) == SolidityPackTypes.BYTES32_TYPE, \"Not bytes32\");\n        dec.pos++;\n        bytes32 val;\n        assembly {\n            let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n            val := mload(ptr)\n        }\n        dec.pos += 32;\n        return val;\n    }\n\n    function decodeBytes(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (bytes memory) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        uint256 len;\n        if (tag == SolidityPackTypes.BYTES8) {\n            len = uint256(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.BYTES16) {\n            len =\n                (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n        } else {\n            revert(\"Not bytes\");\n        }\n\n        bytes memory result = new bytes(len);\n        assembly {\n            let src := add(add(mload(dec), 32), mload(add(dec, 32)))\n            let dst := add(result, 32)\n\n            // Copy full 32-byte chunks\n            let fullChunks := div(len, 32)\n            for { let i := 0 } lt(i, fullChunks) { i := add(i, 1) } {\n                mstore(add(dst, mul(i, 32)), mload(add(src, mul(i, 32))))\n            }\n\n            // Copy remaining bytes if any\n            let remaining := mod(len, 32)\n            if gt(remaining, 0) {\n                let lastChunkOffset := mul(fullChunks, 32)\n                let mask := sub(shl(mul(remaining, 8), 1), 1)\n                let srcData := and(\n                    mload(add(src, lastChunkOffset)),\n                    shl(sub(256, mul(remaining, 8)), mask)\n                )\n                mstore(add(dst, lastChunkOffset), srcData)\n            }\n        }\n        dec.pos += len;\n        return result;\n    }\n\n    function decodeString(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (string memory) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        uint256 len;\n        if (tag >= SolidityPackTypes.FIXSTR_BASE && tag < SolidityPackTypes.FIXSTR_BASE + 32) {\n            len = uint256(tag - SolidityPackTypes.FIXSTR_BASE);\n        } else if (tag == SolidityPackTypes.STR8) {\n            len = uint256(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.STR16) {\n            len =\n                (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n        } else {\n            revert(\"Not string\");\n        }\n\n        bytes memory result = new bytes(len);\n        assembly {\n            let src := add(add(mload(dec), 32), mload(add(dec, 32)))\n            let dst := add(result, 32)\n\n            // Copy full 32-byte chunks\n            let fullChunks := div(len, 32)\n            for { let i := 0 } lt(i, fullChunks) { i := add(i, 1) } {\n                mstore(add(dst, mul(i, 32)), mload(add(src, mul(i, 32))))\n            }\n\n            // Copy remaining bytes if any\n            let remaining := mod(len, 32)\n            if gt(remaining, 0) {\n                let lastChunkOffset := mul(fullChunks, 32)\n                let mask := sub(shl(mul(remaining, 8), 1), 1)\n                let srcData := and(\n                    mload(add(src, lastChunkOffset)),\n                    shl(sub(256, mul(remaining, 8)), mask)\n                )\n                mstore(add(dst, lastChunkOffset), srcData)\n            }\n        }\n        dec.pos += len;\n        return string(result);\n    }\n\n    function decodeArrayLength(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (uint256) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        if (tag >= SolidityPackTypes.FIXARRAY_BASE && tag < SolidityPackTypes.FIXARRAY_BASE + 16) {\n            return uint256(tag - SolidityPackTypes.FIXARRAY_BASE);\n        } else if (tag == SolidityPackTypes.ARRAY8) {\n            return uint256(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.ARRAY16) {\n            uint256 len = (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n            return len;\n        }\n\n        revert(\"Not array\");\n    }\n\n    function decodeMapLength(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (uint256) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        if (tag >= SolidityPackTypes.FIXMAP_BASE && tag < SolidityPackTypes.FIXMAP_BASE + 16) {\n            return uint256(tag - SolidityPackTypes.FIXMAP_BASE);\n        } else if (tag == SolidityPackTypes.MAP8) {\n            return uint256(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.MAP16) {\n            uint256 len = (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n            return len;\n        }\n\n        revert(\"Not map\");\n    }\n\n    // ============ NESTED OBJECT DECODING ============\n\n    /**\n     * @notice Start decoding a nested object (map)\n     * @return Number of key-value pairs\n     */\n    function decodeObjectLength(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (uint256) {\n        return decodeMapLength(dec);\n    }\n\n    /**\n     * @notice Helper to decode array of uints\n     */\n    function decodeUintArray(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (uint256[] memory) {\n        uint256 len = decodeArrayLength(dec);\n        uint256[] memory result = new uint256[](len);\n        for (uint256 i = 0; i < len; i++) {\n            result[i] = decodeUint(dec);\n        }\n        return result;\n    }\n\n    /**\n     * @notice Helper to decode array of addresses\n     */\n    function decodeAddressArray(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (address[] memory) {\n        uint256 len = decodeArrayLength(dec);\n        address[] memory result = new address[](len);\n        for (uint256 i = 0; i < len; i++) {\n            result[i] = decodeAddress(dec);\n        }\n        return result;\n    }\n\n    /**\n     * @notice Helper to decode array of strings\n     */\n    function decodeStringArray(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (string[] memory) {\n        uint256 len = decodeArrayLength(dec);\n        string[] memory result = new string[](len);\n        for (uint256 i = 0; i < len; i++) {\n            result[i] = decodeString(dec);\n        }\n        return result;\n    }\n\n    /**\n     * @notice Skip the next value in the decoder (useful for unknown fields)\n     */\n    function skip(SolidityPackTypes.Decoder memory dec) internal pure {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        // Handle different type categories\n        if (tag <= SolidityPackTypes.FIXINT_POS_MAX || tag >= SolidityPackTypes.FIXINT_NEG_BASE) {\n            // Fixint, already consumed\n            return;\n        } else if (\n            tag >= SolidityPackTypes.FIXSTR_BASE && tag < SolidityPackTypes.FIXSTR_BASE + 32\n        ) {\n            // Fixstr\n            dec.pos += (tag - SolidityPackTypes.FIXSTR_BASE);\n        } else if (\n            tag >= SolidityPackTypes.FIXARRAY_BASE && tag < SolidityPackTypes.FIXARRAY_BASE + 16\n        ) {\n            // Fixarray\n            uint256 len = tag - SolidityPackTypes.FIXARRAY_BASE;\n            for (uint256 i = 0; i < len; i++) {\n                skip(dec);\n            }\n        } else if (\n            tag >= SolidityPackTypes.FIXMAP_BASE && tag < SolidityPackTypes.FIXMAP_BASE + 16\n        ) {\n            // Fixmap\n            uint256 len = tag - SolidityPackTypes.FIXMAP_BASE;\n            for (uint256 i = 0; i < len * 2; i++) {\n                skip(dec);\n            }\n        } else if (\n            tag == SolidityPackTypes.NIL ||\n            tag == SolidityPackTypes.TRUE ||\n            tag == SolidityPackTypes.FALSE\n        ) {\n            // Already consumed\n        } else if (tag == SolidityPackTypes.UINT8 || tag == SolidityPackTypes.INT8) {\n            dec.pos += 1;\n        } else if (tag == SolidityPackTypes.UINT16 || tag == SolidityPackTypes.INT16) {\n            dec.pos += 2;\n        } else if (tag == SolidityPackTypes.UINT32 || tag == SolidityPackTypes.INT32) {\n            dec.pos += 4;\n        } else if (tag == SolidityPackTypes.UINT64 || tag == SolidityPackTypes.INT64) {\n            dec.pos += 8;\n        } else if (tag == SolidityPackTypes.UINT128 || tag == SolidityPackTypes.INT128) {\n            dec.pos += 16;\n        } else if (\n            tag == SolidityPackTypes.UINT256 ||\n            tag == SolidityPackTypes.INT256 ||\n            tag == SolidityPackTypes.BYTES32_TYPE\n        ) {\n            dec.pos += 32;\n        } else if (tag == SolidityPackTypes.ADDRESS) {\n            dec.pos += 20;\n        } else if (tag == SolidityPackTypes.BYTES8 || tag == SolidityPackTypes.STR8) {\n            uint256 len = uint256(uint8(dec.data[dec.pos++]));\n            dec.pos += len;\n        } else if (tag == SolidityPackTypes.BYTES16 || tag == SolidityPackTypes.STR16) {\n            uint256 len = (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2 + len;\n        } else if (tag == SolidityPackTypes.ARRAY8) {\n            uint256 len = uint256(uint8(dec.data[dec.pos++]));\n            for (uint256 i = 0; i < len; i++) {\n                skip(dec);\n            }\n        } else if (tag == SolidityPackTypes.ARRAY16) {\n            uint256 len = (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n            for (uint256 i = 0; i < len; i++) {\n                skip(dec);\n            }\n        } else if (tag == SolidityPackTypes.MAP8) {\n            uint256 len = uint256(uint8(dec.data[dec.pos++]));\n            for (uint256 i = 0; i < len * 2; i++) {\n                skip(dec);\n            }\n        } else if (tag == SolidityPackTypes.MAP16) {\n            uint256 len = (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n            for (uint256 i = 0; i < len * 2; i++) {\n                skip(dec);\n            }\n        } else {\n            revert(\"Unknown type tag\");\n        }\n    }\n}\n"
      },
      "project/contracts/SolidityPackTypes.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title SolidityPackTypes\n * @notice Shared type constants and structs for SolidityPack encoding/decoding\n * @dev This library contains only constants and is optimized away at compile time\n */\n\nlibrary SolidityPackTypes {\n\n    // Type constants\n    uint8 internal constant FIXINT_POS_MAX = 0x7F;\n    uint8 internal constant FIXMAP_BASE = 0x80;\n    uint8 internal constant FIXARRAY_BASE = 0x90;\n    uint8 internal constant FIXSTR_BASE = 0xA0;\n    uint8 internal constant NIL = 0xC0;\n    uint8 internal constant FALSE = 0xC2;\n    uint8 internal constant TRUE = 0xC3;\n    uint8 internal constant UINT8 = 0xC4;\n    uint8 internal constant UINT16 = 0xC5;\n    uint8 internal constant UINT32 = 0xC6;\n    uint8 internal constant UINT64 = 0xC7;\n    uint8 internal constant UINT128 = 0xC8;\n    uint8 internal constant UINT256 = 0xC9;\n    uint8 internal constant INT8 = 0xCA;\n    uint8 internal constant INT16 = 0xCB;\n    uint8 internal constant INT32 = 0xCC;\n    uint8 internal constant INT64 = 0xCD;\n    uint8 internal constant INT128 = 0xCE;\n    uint8 internal constant INT256 = 0xCF;\n    uint8 internal constant BYTES8 = 0xD0;\n    uint8 internal constant BYTES16 = 0xD1;\n    uint8 internal constant STR8 = 0xD2;\n    uint8 internal constant STR16 = 0xD3;\n    uint8 internal constant ADDRESS = 0xD4;\n    uint8 internal constant BYTES32_TYPE = 0xD5;\n    uint8 internal constant ARRAY8 = 0xD6;\n    uint8 internal constant ARRAY16 = 0xD7;\n    uint8 internal constant MAP8 = 0xD8;\n    uint8 internal constant MAP16 = 0xD9;\n    uint8 internal constant FIXINT_NEG_BASE = 0xE0;\n\n    // Growth strategy constants for encoder\n    uint256 internal constant INITIAL_BUFFER_SIZE = 256;\n    uint256 internal constant GROWTH_THRESHOLD = 4096;\n    uint256 internal constant MIN_GROWTH_MARGIN = 128;\n\n    // Encoder struct\n    struct Encoder {\n        bytes buffer;\n        uint256 pos;\n    }\n\n    // Decoder struct\n    struct Decoder {\n        bytes data;\n        uint256 pos;\n    }\n}\n"
      },
      "project/contracts/test/DecoderTest.t.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../SolidityPackDecoder.sol\";\nimport \"../SolidityPackTypes.sol\";\n\n/**\n * @title DecoderTest\n * @notice Test contract demonstrating SolidityPack decoding\n */\ncontract DecoderTest {\n    using SolidityPackDecoder for *;\n\n    // Test decoding: {test: 42, test2: []}\n    // Encoded as: 0x82a4746573742aa5746573743290\n    function testDecodeMapWithEmptyArray() public pure returns (\n        string memory key1,\n        uint256 value1,\n        string memory key2,\n        uint256 arrayLen\n    ) {\n        bytes memory data = hex\"82a4746573742aa5746573743290\";\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        uint256 mapLen = SolidityPackDecoder.decodeMapLength(dec);\n        require(mapLen == 2, \"Expected 2 map entries\");\n\n        key1 = SolidityPackDecoder.decodeString(dec);\n        value1 = SolidityPackDecoder.decodeUint(dec);\n\n        key2 = SolidityPackDecoder.decodeString(dec);\n        arrayLen = SolidityPackDecoder.decodeArrayLength(dec);\n\n        return (key1, value1, key2, arrayLen);\n    }\n\n    // Test generic type inspection\n    function testTypeInspection() public pure returns (\n        bool isMap,\n        bool hasMoreAfterDecode\n    ) {\n        bytes memory data = hex\"82a4746573742aa5746573743290\";\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        // Check if it's a map\n        isMap = SolidityPackDecoder.isCategory(dec, SolidityPackDecoder.TypeCategory.MAP);\n\n        // Decode it\n        SolidityPackDecoder.decodeMapLength(dec);\n        SolidityPackDecoder.skip(dec); // skip key1\n        SolidityPackDecoder.skip(dec); // skip value1\n        SolidityPackDecoder.skip(dec); // skip key2\n        SolidityPackDecoder.skip(dec); // skip value2 (empty array)\n\n        hasMoreAfterDecode = SolidityPackDecoder.hasMore(dec);\n\n        return (isMap, hasMoreAfterDecode);\n    }\n\n    // Test decoding heterogeneous array\n    function testDecodeHeterogeneousArray() public pure returns (\n        uint256 uintVal,\n        string memory strVal,\n        bool boolVal,\n        bool nilDecoded\n    ) {\n        // Encoded: [42, \"hello\", true, null]\n        bytes memory data = hex\"942aa568656c6c6fc3c0\";\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        uint256 len = SolidityPackDecoder.decodeArrayLength(dec);\n        require(len == 4, \"Expected 4 elements\");\n\n        uintVal = SolidityPackDecoder.decodeUint(dec);\n        strVal = SolidityPackDecoder.decodeString(dec);\n        boolVal = SolidityPackDecoder.decodeBool(dec);\n        SolidityPackDecoder.decodeNil(dec);\n        nilDecoded = true;\n\n        return (uintVal, strVal, boolVal, nilDecoded);\n    }\n\n    // Test selective decoding with skip\n    function testSelectiveDecoding() public pure returns (\n        uint256 firstValue,\n        uint256 thirdValue\n    ) {\n        // Map: {a: 1, b: 2, c: 3}\n        bytes memory data = hex\"83a16101a16202a16303\";\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        SolidityPackDecoder.decodeMapLength(dec);\n\n        // Get first value\n        SolidityPackDecoder.decodeString(dec); // key \"a\"\n        firstValue = SolidityPackDecoder.decodeUint(dec); // value 1\n\n        // Skip second entry\n        SolidityPackDecoder.skip(dec); // key \"b\"\n        SolidityPackDecoder.skip(dec); // value 2\n\n        // Get third value\n        SolidityPackDecoder.decodeString(dec); // key \"c\"\n        thirdValue = SolidityPackDecoder.decodeUint(dec); // value 3\n\n        return (firstValue, thirdValue);\n    }\n\n    // Test decoding address\n    function testDecodeAddress() public pure returns (address addr) {\n        // Encoded address: 0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1\n        bytes memory data = hex\"d4742d35Cc6634C0532925a3b844Bc9e7595f0bEb1\";\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        addr = SolidityPackDecoder.decodeAddress(dec);\n        return addr;\n    }\n\n    // Test decoding bytes32\n    function testDecodeBytes32() public pure returns (bytes32 value) {\n        // Encoded bytes32: 0x00000000000000000000000000000000000000000000000000000000deadbeef\n        bytes memory data = hex\"d500000000000000000000000000000000000000000000000000000000deadbeef\";\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        value = SolidityPackDecoder.decodeBytes32(dec);\n        return value;\n    }\n\n    // Test decoding uint array helper\n    function testDecodeUintArray() public pure returns (\n        uint256 len,\n        uint256 first,\n        uint256 last\n    ) {\n        // Encoded: [10, 20, 30]\n        bytes memory data = hex\"930a141e\";\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        uint256[] memory arr = SolidityPackDecoder.decodeUintArray(dec);\n        len = arr.length;\n        first = arr[0];\n        last = arr[arr.length - 1];\n\n        return (len, first, last);\n    }\n\n    // Test decoding address array helper\n    function testDecodeAddressArray() public pure returns (\n        uint256 len,\n        address first,\n        address second\n    ) {\n        // Encoded: [0x1111..., 0x2222...]\n        bytes memory data = hex\"92d41111111111111111111111111111111111111111d42222222222222222222222222222222222222222\";\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        address[] memory arr = SolidityPackDecoder.decodeAddressArray(dec);\n        len = arr.length;\n        first = arr[0];\n        second = arr[1];\n\n        return (len, first, second);\n    }\n\n    // Test decoding string array helper\n    function testDecodeStringArray() public pure returns (\n        uint256 len,\n        string memory first,\n        string memory second\n    ) {\n        // Encoded: [\"hello\", \"world\"]\n        bytes memory data = hex\"92a568656c6c6fa5776f726c64\";\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        string[] memory arr = SolidityPackDecoder.decodeStringArray(dec);\n        len = arr.length;\n        first = arr[0];\n        second = arr[1];\n\n        return (len, first, second);\n    }\n\n    // Test decoding nested objects\n    function testDecodeNestedObject() public pure returns (\n        string memory name,\n        uint256 age,\n        uint256 tagsLen,\n        string memory firstTag\n    ) {\n        // {name: \"Alice\", age: 30, tags: [\"user\", \"active\"]}\n        bytes memory data = hex\"83a46e616d65a5416c696365a36167651ea47461677392a475736572a6616374697665\";\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        uint256 mapLen = SolidityPackDecoder.decodeMapLength(dec);\n        require(mapLen == 3, \"Expected 3 fields\");\n\n        // name\n        SolidityPackDecoder.decodeString(dec); // key\n        name = SolidityPackDecoder.decodeString(dec);\n\n        // age\n        SolidityPackDecoder.decodeString(dec); // key\n        age = SolidityPackDecoder.decodeUint(dec);\n\n        // tags\n        SolidityPackDecoder.decodeString(dec); // key\n        string[] memory tags = SolidityPackDecoder.decodeStringArray(dec);\n        tagsLen = tags.length;\n        firstTag = tags[0];\n\n        return (name, age, tagsLen, firstTag);\n    }\n\n    // Test peekCategory for different types\n    function testPeekCategory() public pure returns (\n        bool allCorrect\n    ) {\n        bytes memory data = hex\"96c32aad48656c6c6fc0d41111111111111111111111111111111111111111d500000000000000000000000000000000000000000000000000000000deadbeef\";\n        // Array: [true, 42, \"Hello\", null, address, bytes32]\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        SolidityPackDecoder.decodeArrayLength(dec);\n\n        bool c1 = SolidityPackDecoder.peekCategory(dec) == SolidityPackDecoder.TypeCategory.BOOL;\n        SolidityPackDecoder.skip(dec);\n\n        bool c2 = SolidityPackDecoder.peekCategory(dec) == SolidityPackDecoder.TypeCategory.UINT;\n        SolidityPackDecoder.skip(dec);\n\n        bool c3 = SolidityPackDecoder.peekCategory(dec) == SolidityPackDecoder.TypeCategory.STRING;\n        SolidityPackDecoder.skip(dec);\n\n        bool c4 = SolidityPackDecoder.peekCategory(dec) == SolidityPackDecoder.TypeCategory.NIL;\n        SolidityPackDecoder.skip(dec);\n\n        bool c5 = SolidityPackDecoder.peekCategory(dec) == SolidityPackDecoder.TypeCategory.ADDRESS;\n        SolidityPackDecoder.skip(dec);\n\n        bool c6 = SolidityPackDecoder.peekCategory(dec) == SolidityPackDecoder.TypeCategory.BYTES32;\n        SolidityPackDecoder.skip(dec);\n\n        allCorrect = c1 && c2 && c3 && c4 && c5 && c6;\n        return allCorrect;\n    }\n\n    // Test decoding large numbers\n    function testDecodeLargeNumbers() public pure returns (\n        uint256 val1,\n        uint256 val2\n    ) {\n        // [type(uint64).max, type(uint128).max]\n        bytes memory data = hex\"92c7ffffffffffffffffc8ffffffffffffffffffffffffffffffffffffffff\";\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        SolidityPackDecoder.decodeArrayLength(dec);\n        val1 = SolidityPackDecoder.decodeUint(dec);\n        val2 = SolidityPackDecoder.decodeUint(dec);\n\n        return (val1, val2);\n    }\n\n    // Test decoding negative numbers\n    function testDecodeNegativeNumbers() public pure returns (\n        int256 val1,\n        int256 val2,\n        int256 val3\n    ) {\n        // [-1, -128, type(int32).min]\n        bytes memory data = hex\"93ffca80cc80000000\";\n        SolidityPackTypes.Decoder memory dec = SolidityPackDecoder.newDecoder(data);\n\n        SolidityPackDecoder.decodeArrayLength(dec);\n        val1 = SolidityPackDecoder.decodeInt(dec);\n        val2 = SolidityPackDecoder.decodeInt(dec);\n        val3 = SolidityPackDecoder.decodeInt(dec);\n\n        return (val1, val2, val3);\n    }\n}\n"
      }
    }
  }
}