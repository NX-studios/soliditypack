{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-291b827980c63e54964ffedf78e56246a606e21f",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/SolidityPackDecoder.sol": "project/contracts/SolidityPackDecoder.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/SolidityPackDecoder.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./SolidityPackTypes.sol\";\n\n/**\n * @title SolidityPackDecoder\n * @notice Ultra gas-efficient decoding for SolidityPack format\n * @dev Decoder-only library to save bytecode in contracts that only decode\n */\n\nlibrary SolidityPackDecoder {\n    using SolidityPackTypes for *;\n\n    // ============ TYPE CATEGORIES ============\n\n    enum TypeCategory {\n        NIL,\n        BOOL,\n        UINT,\n        INT,\n        BYTES,\n        STRING,\n        ARRAY,\n        MAP,\n        ADDRESS,\n        BYTES32\n    }\n\n    // ============ GENERIC TYPE INSPECTION ============\n\n    /**\n     * @notice Get the category of the next value without consuming it\n     * @dev Useful for dynamic decoding when you don't know the type ahead of time\n     */\n    function peekCategory(SolidityPackTypes.Decoder memory dec) internal pure returns (TypeCategory) {\n        require(dec.pos < dec.data.length, \"EOF\");\n        uint8 tag = uint8(dec.data[dec.pos]);\n\n        if (tag == SolidityPackTypes.NIL) {\n            return TypeCategory.NIL;\n        } else if (tag == SolidityPackTypes.TRUE || tag == SolidityPackTypes.FALSE) {\n            return TypeCategory.BOOL;\n        } else if (\n            tag <= SolidityPackTypes.FIXINT_POS_MAX ||\n            tag == SolidityPackTypes.UINT8 ||\n            tag == SolidityPackTypes.UINT16 ||\n            tag == SolidityPackTypes.UINT32 ||\n            tag == SolidityPackTypes.UINT64 ||\n            tag == SolidityPackTypes.UINT128 ||\n            tag == SolidityPackTypes.UINT256\n        ) {\n            return TypeCategory.UINT;\n        } else if (\n            tag >= SolidityPackTypes.FIXINT_NEG_BASE ||\n            tag == SolidityPackTypes.INT8 ||\n            tag == SolidityPackTypes.INT16 ||\n            tag == SolidityPackTypes.INT32 ||\n            tag == SolidityPackTypes.INT64 ||\n            tag == SolidityPackTypes.INT128 ||\n            tag == SolidityPackTypes.INT256\n        ) {\n            return TypeCategory.INT;\n        } else if (tag == SolidityPackTypes.BYTES8 || tag == SolidityPackTypes.BYTES16) {\n            return TypeCategory.BYTES;\n        } else if (\n            (tag >= SolidityPackTypes.FIXSTR_BASE && tag < SolidityPackTypes.FIXSTR_BASE + 32) ||\n            tag == SolidityPackTypes.STR8 ||\n            tag == SolidityPackTypes.STR16\n        ) {\n            return TypeCategory.STRING;\n        } else if (\n            (tag >= SolidityPackTypes.FIXARRAY_BASE && tag < SolidityPackTypes.FIXARRAY_BASE + 16) ||\n            tag == SolidityPackTypes.ARRAY8 ||\n            tag == SolidityPackTypes.ARRAY16\n        ) {\n            return TypeCategory.ARRAY;\n        } else if (\n            (tag >= SolidityPackTypes.FIXMAP_BASE && tag < SolidityPackTypes.FIXMAP_BASE + 16) ||\n            tag == SolidityPackTypes.MAP8 ||\n            tag == SolidityPackTypes.MAP16\n        ) {\n            return TypeCategory.MAP;\n        } else if (tag == SolidityPackTypes.ADDRESS) {\n            return TypeCategory.ADDRESS;\n        } else if (tag == SolidityPackTypes.BYTES32_TYPE) {\n            return TypeCategory.BYTES32;\n        }\n\n        revert(\"Unknown type tag\");\n    }\n\n    /**\n     * @notice Check if the next value is of a specific category\n     * @dev Useful for conditional decoding\n     */\n    function isCategory(\n        SolidityPackTypes.Decoder memory dec,\n        TypeCategory category\n    ) internal pure returns (bool) {\n        if (dec.pos >= dec.data.length) return false;\n        return peekCategory(dec) == category;\n    }\n\n    /**\n     * @notice Check if decoder has more data to read\n     */\n    function hasMore(SolidityPackTypes.Decoder memory dec) internal pure returns (bool) {\n        return dec.pos < dec.data.length;\n    }\n\n    // ============ DECODER FUNCTIONS ============\n\n    function newDecoder(bytes memory data) internal pure returns (SolidityPackTypes.Decoder memory) {\n        return SolidityPackTypes.Decoder(data, 0);\n    }\n\n    function peekType(SolidityPackTypes.Decoder memory dec) internal pure returns (uint8) {\n        require(dec.pos < dec.data.length, \"EOF\");\n        return uint8(dec.data[dec.pos]);\n    }\n\n    function decodeBool(SolidityPackTypes.Decoder memory dec) internal pure returns (bool) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n        require(tag == SolidityPackTypes.TRUE || tag == SolidityPackTypes.FALSE, \"Not bool\");\n        return tag == SolidityPackTypes.TRUE;\n    }\n\n    function decodeNil(SolidityPackTypes.Decoder memory dec) internal pure {\n        require(peekType(dec) == SolidityPackTypes.NIL, \"Not nil\");\n        dec.pos++;\n    }\n\n    function decodeUint(SolidityPackTypes.Decoder memory dec) internal pure returns (uint256) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        if (tag <= SolidityPackTypes.FIXINT_POS_MAX) {\n            return uint256(tag);\n        } else if (tag == SolidityPackTypes.UINT8) {\n            return uint256(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.UINT16) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := or(shl(8, byte(0, mload(ptr))), byte(0, mload(add(ptr, 1))))\n            }\n            dec.pos += 2;\n            return val;\n        } else if (tag == SolidityPackTypes.UINT32) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := or(\n                    or(\n                        or(shl(24, byte(0, mload(ptr))), shl(16, byte(0, mload(add(ptr, 1))))),\n                        shl(8, byte(0, mload(add(ptr, 2))))\n                    ),\n                    byte(0, mload(add(ptr, 3)))\n                )\n            }\n            dec.pos += 4;\n            return val;\n        } else if (tag == SolidityPackTypes.UINT64) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := 0\n                for { let i := 0 } lt(i, 8) { i := add(i, 1) } {\n                    val := or(shl(8, val), byte(0, mload(add(ptr, i))))\n                }\n            }\n            dec.pos += 8;\n            return val;\n        } else if (tag == SolidityPackTypes.UINT128) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := 0\n                for { let i := 0 } lt(i, 16) { i := add(i, 1) } {\n                    val := or(shl(8, val), byte(0, mload(add(ptr, i))))\n                }\n            }\n            dec.pos += 16;\n            return val;\n        } else if (tag == SolidityPackTypes.UINT256) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := mload(ptr)\n            }\n            dec.pos += 32;\n            return val;\n        }\n\n        revert(\"Invalid uint tag\");\n    }\n\n    function decodeInt(SolidityPackTypes.Decoder memory dec) internal pure returns (int256) {\n        uint8 tag = peekType(dec);\n\n        if (tag <= SolidityPackTypes.FIXINT_POS_MAX) {\n            dec.pos++;\n            return int256(uint256(tag));\n        } else if (tag >= SolidityPackTypes.FIXINT_NEG_BASE) {\n            dec.pos++;\n            return\n                int8(uint8(tag)) -\n                int8(uint8(SolidityPackTypes.FIXINT_NEG_BASE)) -\n                32;\n        }\n\n        dec.pos++;\n\n        if (tag == SolidityPackTypes.INT8) {\n            return int8(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.INT16) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := or(shl(8, byte(0, mload(ptr))), byte(0, mload(add(ptr, 1))))\n                // Use signextend opcode\n                val := signextend(1, val)\n            }\n            dec.pos += 2;\n            return int256(val);\n        } else if (tag == SolidityPackTypes.INT32) {\n            uint256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := or(\n                    or(\n                        or(shl(24, byte(0, mload(ptr))), shl(16, byte(0, mload(add(ptr, 1))))),\n                        shl(8, byte(0, mload(add(ptr, 2))))\n                    ),\n                    byte(0, mload(add(ptr, 3)))\n                )\n                // Use signextend opcode\n                val := signextend(3, val)\n            }\n            dec.pos += 4;\n            return int256(val);\n        } else if (tag == SolidityPackTypes.INT256) {\n            int256 val;\n            assembly {\n                let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n                val := mload(ptr)\n            }\n            dec.pos += 32;\n            return val;\n        }\n\n        revert(\"Invalid int tag\");\n    }\n\n    function decodeAddress(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (address) {\n        require(peekType(dec) == SolidityPackTypes.ADDRESS, \"Not address\");\n        dec.pos++;\n        address val;\n        assembly {\n            let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n            val := shr(96, mload(ptr))\n        }\n        dec.pos += 20;\n        return val;\n    }\n\n    function decodeBytes32(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (bytes32) {\n        require(peekType(dec) == SolidityPackTypes.BYTES32_TYPE, \"Not bytes32\");\n        dec.pos++;\n        bytes32 val;\n        assembly {\n            let ptr := add(add(mload(dec), 32), mload(add(dec, 32)))\n            val := mload(ptr)\n        }\n        dec.pos += 32;\n        return val;\n    }\n\n    function decodeBytes(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (bytes memory) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        uint256 len;\n        if (tag == SolidityPackTypes.BYTES8) {\n            len = uint256(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.BYTES16) {\n            len =\n                (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n        } else {\n            revert(\"Not bytes\");\n        }\n\n        bytes memory result = new bytes(len);\n        assembly {\n            let src := add(add(mload(dec), 32), mload(add(dec, 32)))\n            let dst := add(result, 32)\n\n            // Copy full 32-byte chunks\n            let fullChunks := div(len, 32)\n            for { let i := 0 } lt(i, fullChunks) { i := add(i, 1) } {\n                mstore(add(dst, mul(i, 32)), mload(add(src, mul(i, 32))))\n            }\n\n            // Copy remaining bytes if any\n            let remaining := mod(len, 32)\n            if gt(remaining, 0) {\n                let lastChunkOffset := mul(fullChunks, 32)\n                let mask := sub(shl(mul(remaining, 8), 1), 1)\n                let srcData := and(\n                    mload(add(src, lastChunkOffset)),\n                    shl(sub(256, mul(remaining, 8)), mask)\n                )\n                mstore(add(dst, lastChunkOffset), srcData)\n            }\n        }\n        dec.pos += len;\n        return result;\n    }\n\n    function decodeString(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (string memory) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        uint256 len;\n        if (tag >= SolidityPackTypes.FIXSTR_BASE && tag < SolidityPackTypes.FIXSTR_BASE + 32) {\n            len = uint256(tag - SolidityPackTypes.FIXSTR_BASE);\n        } else if (tag == SolidityPackTypes.STR8) {\n            len = uint256(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.STR16) {\n            len =\n                (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n        } else {\n            revert(\"Not string\");\n        }\n\n        bytes memory result = new bytes(len);\n        assembly {\n            let src := add(add(mload(dec), 32), mload(add(dec, 32)))\n            let dst := add(result, 32)\n\n            // Copy full 32-byte chunks\n            let fullChunks := div(len, 32)\n            for { let i := 0 } lt(i, fullChunks) { i := add(i, 1) } {\n                mstore(add(dst, mul(i, 32)), mload(add(src, mul(i, 32))))\n            }\n\n            // Copy remaining bytes if any\n            let remaining := mod(len, 32)\n            if gt(remaining, 0) {\n                let lastChunkOffset := mul(fullChunks, 32)\n                let mask := sub(shl(mul(remaining, 8), 1), 1)\n                let srcData := and(\n                    mload(add(src, lastChunkOffset)),\n                    shl(sub(256, mul(remaining, 8)), mask)\n                )\n                mstore(add(dst, lastChunkOffset), srcData)\n            }\n        }\n        dec.pos += len;\n        return string(result);\n    }\n\n    function decodeArrayLength(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (uint256) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        if (tag >= SolidityPackTypes.FIXARRAY_BASE && tag < SolidityPackTypes.FIXARRAY_BASE + 16) {\n            return uint256(tag - SolidityPackTypes.FIXARRAY_BASE);\n        } else if (tag == SolidityPackTypes.ARRAY8) {\n            return uint256(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.ARRAY16) {\n            uint256 len = (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n            return len;\n        }\n\n        revert(\"Not array\");\n    }\n\n    function decodeMapLength(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (uint256) {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        if (tag >= SolidityPackTypes.FIXMAP_BASE && tag < SolidityPackTypes.FIXMAP_BASE + 16) {\n            return uint256(tag - SolidityPackTypes.FIXMAP_BASE);\n        } else if (tag == SolidityPackTypes.MAP8) {\n            return uint256(uint8(dec.data[dec.pos++]));\n        } else if (tag == SolidityPackTypes.MAP16) {\n            uint256 len = (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n            return len;\n        }\n\n        revert(\"Not map\");\n    }\n\n    // ============ NESTED OBJECT DECODING ============\n\n    /**\n     * @notice Start decoding a nested object (map)\n     * @return Number of key-value pairs\n     */\n    function decodeObjectLength(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (uint256) {\n        return decodeMapLength(dec);\n    }\n\n    /**\n     * @notice Helper to decode array of uints\n     */\n    function decodeUintArray(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (uint256[] memory) {\n        uint256 len = decodeArrayLength(dec);\n        uint256[] memory result = new uint256[](len);\n        for (uint256 i = 0; i < len; i++) {\n            result[i] = decodeUint(dec);\n        }\n        return result;\n    }\n\n    /**\n     * @notice Helper to decode array of addresses\n     */\n    function decodeAddressArray(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (address[] memory) {\n        uint256 len = decodeArrayLength(dec);\n        address[] memory result = new address[](len);\n        for (uint256 i = 0; i < len; i++) {\n            result[i] = decodeAddress(dec);\n        }\n        return result;\n    }\n\n    /**\n     * @notice Helper to decode array of strings\n     */\n    function decodeStringArray(\n        SolidityPackTypes.Decoder memory dec\n    ) internal pure returns (string[] memory) {\n        uint256 len = decodeArrayLength(dec);\n        string[] memory result = new string[](len);\n        for (uint256 i = 0; i < len; i++) {\n            result[i] = decodeString(dec);\n        }\n        return result;\n    }\n\n    /**\n     * @notice Skip the next value in the decoder (useful for unknown fields)\n     */\n    function skip(SolidityPackTypes.Decoder memory dec) internal pure {\n        uint8 tag = peekType(dec);\n        dec.pos++;\n\n        // Handle different type categories\n        if (tag <= SolidityPackTypes.FIXINT_POS_MAX || tag >= SolidityPackTypes.FIXINT_NEG_BASE) {\n            // Fixint, already consumed\n            return;\n        } else if (\n            tag >= SolidityPackTypes.FIXSTR_BASE && tag < SolidityPackTypes.FIXSTR_BASE + 32\n        ) {\n            // Fixstr\n            dec.pos += (tag - SolidityPackTypes.FIXSTR_BASE);\n        } else if (\n            tag >= SolidityPackTypes.FIXARRAY_BASE && tag < SolidityPackTypes.FIXARRAY_BASE + 16\n        ) {\n            // Fixarray\n            uint256 len = tag - SolidityPackTypes.FIXARRAY_BASE;\n            for (uint256 i = 0; i < len; i++) {\n                skip(dec);\n            }\n        } else if (\n            tag >= SolidityPackTypes.FIXMAP_BASE && tag < SolidityPackTypes.FIXMAP_BASE + 16\n        ) {\n            // Fixmap\n            uint256 len = tag - SolidityPackTypes.FIXMAP_BASE;\n            for (uint256 i = 0; i < len * 2; i++) {\n                skip(dec);\n            }\n        } else if (\n            tag == SolidityPackTypes.NIL ||\n            tag == SolidityPackTypes.TRUE ||\n            tag == SolidityPackTypes.FALSE\n        ) {\n            // Already consumed\n        } else if (tag == SolidityPackTypes.UINT8 || tag == SolidityPackTypes.INT8) {\n            dec.pos += 1;\n        } else if (tag == SolidityPackTypes.UINT16 || tag == SolidityPackTypes.INT16) {\n            dec.pos += 2;\n        } else if (tag == SolidityPackTypes.UINT32 || tag == SolidityPackTypes.INT32) {\n            dec.pos += 4;\n        } else if (tag == SolidityPackTypes.UINT64 || tag == SolidityPackTypes.INT64) {\n            dec.pos += 8;\n        } else if (tag == SolidityPackTypes.UINT128 || tag == SolidityPackTypes.INT128) {\n            dec.pos += 16;\n        } else if (\n            tag == SolidityPackTypes.UINT256 ||\n            tag == SolidityPackTypes.INT256 ||\n            tag == SolidityPackTypes.BYTES32_TYPE\n        ) {\n            dec.pos += 32;\n        } else if (tag == SolidityPackTypes.ADDRESS) {\n            dec.pos += 20;\n        } else if (tag == SolidityPackTypes.BYTES8 || tag == SolidityPackTypes.STR8) {\n            uint256 len = uint256(uint8(dec.data[dec.pos++]));\n            dec.pos += len;\n        } else if (tag == SolidityPackTypes.BYTES16 || tag == SolidityPackTypes.STR16) {\n            uint256 len = (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2 + len;\n        } else if (tag == SolidityPackTypes.ARRAY8) {\n            uint256 len = uint256(uint8(dec.data[dec.pos++]));\n            for (uint256 i = 0; i < len; i++) {\n                skip(dec);\n            }\n        } else if (tag == SolidityPackTypes.ARRAY16) {\n            uint256 len = (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n            for (uint256 i = 0; i < len; i++) {\n                skip(dec);\n            }\n        } else if (tag == SolidityPackTypes.MAP8) {\n            uint256 len = uint256(uint8(dec.data[dec.pos++]));\n            for (uint256 i = 0; i < len * 2; i++) {\n                skip(dec);\n            }\n        } else if (tag == SolidityPackTypes.MAP16) {\n            uint256 len = (uint256(uint8(dec.data[dec.pos])) << 8) |\n                uint256(uint8(dec.data[dec.pos + 1]));\n            dec.pos += 2;\n            for (uint256 i = 0; i < len * 2; i++) {\n                skip(dec);\n            }\n        } else {\n            revert(\"Unknown type tag\");\n        }\n    }\n}\n"
      },
      "project/contracts/SolidityPackTypes.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title SolidityPackTypes\n * @notice Shared type constants and structs for SolidityPack encoding/decoding\n * @dev This library contains only constants and is optimized away at compile time\n */\n\nlibrary SolidityPackTypes {\n\n    // Type constants\n    uint8 internal constant FIXINT_POS_MAX = 0x7F;\n    uint8 internal constant FIXMAP_BASE = 0x80;\n    uint8 internal constant FIXARRAY_BASE = 0x90;\n    uint8 internal constant FIXSTR_BASE = 0xA0;\n    uint8 internal constant NIL = 0xC0;\n    uint8 internal constant FALSE = 0xC2;\n    uint8 internal constant TRUE = 0xC3;\n    uint8 internal constant UINT8 = 0xC4;\n    uint8 internal constant UINT16 = 0xC5;\n    uint8 internal constant UINT32 = 0xC6;\n    uint8 internal constant UINT64 = 0xC7;\n    uint8 internal constant UINT128 = 0xC8;\n    uint8 internal constant UINT256 = 0xC9;\n    uint8 internal constant INT8 = 0xCA;\n    uint8 internal constant INT16 = 0xCB;\n    uint8 internal constant INT32 = 0xCC;\n    uint8 internal constant INT64 = 0xCD;\n    uint8 internal constant INT128 = 0xCE;\n    uint8 internal constant INT256 = 0xCF;\n    uint8 internal constant BYTES8 = 0xD0;\n    uint8 internal constant BYTES16 = 0xD1;\n    uint8 internal constant STR8 = 0xD2;\n    uint8 internal constant STR16 = 0xD3;\n    uint8 internal constant ADDRESS = 0xD4;\n    uint8 internal constant BYTES32_TYPE = 0xD5;\n    uint8 internal constant ARRAY8 = 0xD6;\n    uint8 internal constant ARRAY16 = 0xD7;\n    uint8 internal constant MAP8 = 0xD8;\n    uint8 internal constant MAP16 = 0xD9;\n    uint8 internal constant FIXINT_NEG_BASE = 0xE0;\n\n    // Growth strategy constants for encoder\n    uint256 internal constant INITIAL_BUFFER_SIZE = 256;\n    uint256 internal constant GROWTH_THRESHOLD = 4096;\n    uint256 internal constant MIN_GROWTH_MARGIN = 128;\n\n    // Encoder struct\n    struct Encoder {\n        bytes buffer;\n        uint256 pos;\n    }\n\n    // Decoder struct\n    struct Decoder {\n        bytes data;\n        uint256 pos;\n    }\n}\n"
      }
    }
  }
}